

## üß† PROJECT OVERVIEW

**Product Name:** Velora
**Core Objective:** A Web3 fiat-to-crypto and crypto-to-fiat gateway for bridged stablecoins (USDC/USDT) on the 0G Network.
**Architecture:** Frontend (React + Vite) ‚Üí Backend (Node.js + Express) ‚Üí 0G Blockchain (Smart Contracts + Storage + Compute).
**Design Goal:** Sleek, futuristic dark interface with pink accent lines and motion micro-interactions.
**Target Users:** DeFi users, traders, and Web3 startups integrating ramp APIs.

---
Note; use rainbowsdk for wallet connect 

## üé® 1. FRONTEND UI/UX DESIGN PROMPT

> üßæ **Prompt (copy/paste for Figma / v0 / Framer / Cursor UI-design model):**

> ‚ÄúDesign a **professional, futuristic dark-mode interface** for a **Web3 On-Ramp & Off-Ramp Tool** named **RampFlow** (you can replace with project name).
> Use **black background (#0A0A0A)**, **electric pink (#FF4FD8)** and **subtle gradients of gray (#1A1A1A to #222222)**.
> Typography: **Poppins / Inter**. Buttons: rounded-2xl, glowing hover states.
>
> ### üß© Core Screens:
>
> 1. **Landing Page**
>
>    * Hero section with tagline ‚ÄúSeamless Fiat ‚Üî Stablecoin Bridge on 0G Network.‚Äù
>    * CTA buttons: [On-Ramp] [Off-Ramp] [Developers].
>    * Short feature highlights: ‚ÄúSecure‚Äù, ‚ÄúInstant‚Äù, ‚ÄúImmutable Receipts‚Äù, ‚Äú0G-Powered.‚Äù
> 2. **User Dashboard**
>
>    * Sidebar: Logo, Dashboard, Transactions, Developer API, Settings.
>    * Main area cards:
>
>      * **Balance Card:** Show wallet address, connected wallet, current bridged USDC.
>      * **On-Ramp Widget:** Input fiat amount ‚Üí select currency ‚Üí payment method ‚Üí confirm.
>      * **Off-Ramp Widget:** Input USDC amount ‚Üí select payout method ‚Üí view status.
>    * Activity timeline showing transaction receipts (linked to 0G Storage CIDs).
> 3. **Transaction History**
>
>    * Table with columns: Date, Type, Amount, TxHash, 0G CID, Status.
>    * Filter options (On-Ramp, Off-Ramp, Success, Failed).
>    * Clickable rows ‚Üí modal with full receipt info (from 0G Storage).
> 4. **Developer API Page**
>
>    * Copyable API keys.
>    * Endpoint documentation preview (Swagger-style).
>    * Code snippet tabs (Node, Python, cURL).
> 5. **KYC Verification Modal**
>
>    * Upload ID (simulated).
>    * Store minimal hash on 0G.
> 6. **Success/Error states**
>
>    * Lottie or Framer Motion animations for transaction complete/error.
>
> ### ü™Ñ Interaction & Motion:
>
> * Hover glow around buttons and cards.
> * Animated loading bar for transactions.
> * Subtle background particle effect in hero.
>
> ### üß≠ Layout System:
>
> * Use **12-column responsive grid**.
> * Define design tokens for: spacing, radii, shadows, typography.
>
> ### üß∞ Deliverables:
>
> * Figma components: Buttons, Inputs, Modals, Cards, Sidebar, Tables.
> * Style Guide page (colors, typography, gradients, motion principles).
> * Export developer-ready assets (SVG icons, logos, gradient overlays).
>
> ### Inspiration:
>
> * Rainbow Wallet, 0x Dashboard, Stripe Dashboard, Coinbase Commerce.‚Äù

---

## ‚öôÔ∏è 2. BACKEND (NODE + EXPRESS) PROMPT

> üßæ **Prompt (for AI coder like Cursor or Claude):**

> ‚ÄúGenerate a **modular Node.js + Express backend** for a Web3 fiat-on/off-ramp service called **Velora**.
> The backend handles payment sessions, webhook callbacks, stablecoin transfers via a smart contract, and 0G Storage logging.
>
> ### üß© Architecture:
>
> * `server.js` ‚Äî Express app entry
> * `/routes` ‚Äî REST endpoints (`onramp.js`, `offramp.js`, `webhook.js`, `admin.js`)
> * `/controllers` ‚Äî logic for payment, blockchain transfer, storage upload
> * `/services` ‚Äî helper modules (`paymentService.js`, `ogStorageService.js`, `walletService.js`)
> * `/config` ‚Äî env vars (payment keys, wallet PKs, 0G API keys)
> * `/db` ‚Äî SQLite ORM (Prisma or Sequelize)
> * `/jobs` ‚Äî queue (BullMQ / simple job processor)
>
> ### üßæ Core APIs:
>
> **1Ô∏è‚É£ POST /api/onramp/create-session**
> ‚Üí Inputs: walletAddress, fiatAmount, currency
> ‚Üí Logic:
> - Create payment intent (Stripe/Paystack)
> - Store session in DB
> - Return clientToken / paymentUrl
>
> **2Ô∏è‚É£ POST /api/webhook/payment**
> ‚Üí Receives payment provider callback
> ‚Üí Verifies signature
> ‚Üí If success: enqueue blockchain transfer job
> ‚Üí Save receipt (JSON) to 0G Storage (get CID)
> ‚Üí Update DB transaction status.
>
> **3Ô∏è‚É£ POST /api/offramp/request**
> ‚Üí Inputs: walletAddress, amount, payoutMethod
> ‚Üí Generates depositRef (memo)
> ‚Üí Waits for on-chain transfer (bridge watcher).
>
> **4Ô∏è‚É£ GET /api/transactions/:userId**
> ‚Üí Returns user tx history (with storage CIDs).
>
> ### üßÆ Database Schema (SQLite):
>
> * users(id, wallet, email, createdAt)
> * sessions(id, userId, type, fiatAmount, token, status, createdAt)
> * transactions(id, sessionId, txHash, storageCid, amount, status, createdAt)
>
> ### üîê Security:
>
> * Use `dotenv` for env variables.
> * Verify webhook signature before processing.
> * No private key exposure ‚Äî use encrypted vault.
>
> ### üöÄ Deployment:
>
> * Containerize using Dockerfile + docker-compose.
> * Expose API via Nginx reverse proxy.
> * Optional: deploy on Railway.app or Render.
>
> ### üß© Extras:
>
> * Integrate with 0G SDK for Storage and Compute.
> * Add rate limits (express-rate-limit).
> * Include detailed README + Postman collection.‚Äù

---

## üîó 3. SMART CONTRACT PROMPT (EVM / 0G BRIDGED STABLECOINS)

> üßæ **Prompt (for AI coder or Solidity expert):**

> ‚ÄúWrite a **Solidity smart contract suite** for a Web3 On-Ramp & Off-Ramp system that interacts with **bridged USDC/USDT tokens on the 0G chain**.
> Use Solidity ‚â•0.8.20 and OpenZeppelin standards.
>
> ### üß© Contracts:
>
> **1Ô∏è‚É£ RampVault.sol**
>
> * Holds bridged stablecoins.
> * Functions:
>
>   * `deposit(address token, uint256 amount)`
>   * `withdraw(address token, uint256 amount, address to)` (only backend signer)
>   * `getVaultBalance(address token)`
> * Emit events: `Deposited`, `Withdrawn`.
> * Restrict control to backend signer (off-chain Node wallet).
>
> **2Ô∏è‚É£ ReceiptRegistry.sol**
>
> * Logs 0G Storage CIDs of receipts.
> * Mapping: `txHash ‚Üí string cid`.
> * Functions: `registerReceipt(bytes32 txHash, string memory cid)`; `getReceipt(txHash)`;
> * Publicly viewable for auditability.
>
> **3Ô∏è‚É£ RampAdmin.sol**
>
> * Role-based access using OpenZeppelin `AccessControl`.
> * Roles: `ADMIN_ROLE`, `WORKER_ROLE`.
> * Manage pause/unpause, contract ownership, fee configurations.
>
> ### üß© Flow:
>
> * Backend detects successful fiat payment ‚Üí calls `RampVault.withdraw()` to send bridged USDC to user wallet.
> * Off-ramp: user sends USDC to vault ‚Üí backend detects `Deposited` event ‚Üí triggers fiat payout.
> * Every transaction logs a receipt hash on-chain using `ReceiptRegistry`.
>
> ### üîê Security & Gas:
>
> * Use ReentrancyGuard.
> * Add `onlyRole(WORKER_ROLE)` modifiers.
> * Low gas design (no on-chain storage of KYC, only CIDs).
>
> ### ‚öôÔ∏è Deployment:
>
> * Deploy to 0G testnet.
> * Verify contracts.
> * Integrate with backend via Ethers.js or 0G SDK.
> * Write sample scripts for:
>
>   * Deposit test
>   * Withdraw test
>   * Register + fetch receipt.
>
> ### ‚úÖ Tests:
>
> * Mocha/Chai or Foundry test suite.
> * Ensure permission checks and balance updates work.‚Äù

---

## üß± BONUS: INTEGRATION PROMPT (Optional for full-stack AI agent)

> ‚ÄúIntegrate the **frontend, backend, and smart contract stack** for Velora:
>
> * Wallet connect (RainbowKit / MetaMask) in frontend.
> * Backend `.env` manages `PRIVATE_KEY`, `0G_RPC_URL`, `PAYMENT_SECRET`, `STORAGE_API_KEY`.
> * Frontend calls backend for `/create-session` ‚Üí user pays ‚Üí backend listens to webhook ‚Üí executes smart contract transfer ‚Üí returns receipt CID.
> * Off-ramp: backend listens for Vault `Deposit` event ‚Üí initiates fiat payout via provider API ‚Üí stores new CID ‚Üí updates frontend via websocket or polling.
> * Deploy whole system using Docker Compose (frontend + backend + 0G node container).‚Äù

---

Would you like me to generate a **follow-up prompt** that produces **UI wireframes + color system + typography + button specs (in Figma-ready format)** for the frontend next?
That would complete your ‚Äú$1M visual blueprint.‚Äù
